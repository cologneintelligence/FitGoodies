package de.cologneintelligence.fitgoodies;

// Copyright (c) 2002-2005 Cunningham & Cunningham, Inc.
// Released under the terms of the GNU General Public License version 2 or later.

import de.cologneintelligence.fitgoodies.adapters.TypeAdapterHelper;
import de.cologneintelligence.fitgoodies.parsers.ParserHelper;
import de.cologneintelligence.fitgoodies.references.CrossReferenceHelper;
import de.cologneintelligence.fitgoodies.util.DependencyManager;
import de.cologneintelligence.fitgoodies.util.FitUtils;
import de.cologneintelligence.fitgoodies.util.FixtureTools;

public class Fixture {

	private Counts counts = new Counts();

	protected String[] args;

	private String cellParameter;


	/**
	 * Sets the fixture parameters.
	 * <p/>
	 * Normally, these values are generated by reading the first line of the
	 * table. This method is primary useful for debugging. You won't need it
	 * otherwise.
	 *
	 * @param args parameters to store in {@code args}
	 */
	public final void setParams(final String[] args) {
		this.args = args;
	}


	/**
	 * Looks up a given parameter in the fixture's argument list.
	 *
	 * @param paramName the parameter name to look up
	 * @return  the parameter value, if it could be found, {@code null} otherwise
	 * @see #getParam(String, String) {@link #getParam(String, String)}
	 * @see FixtureTools#getArg(String[], String, String, de.cologneintelligence.fitgoodies.references.CrossReferenceHelper)
	 * 		{@link FixtureTools#getArg(String[], String, String, de.cologneintelligence.fitgoodies.references.CrossReferenceHelper)}
	 */
	public final String getParam(final String paramName) {
		return getParam(paramName, null);
	}

	/**
	 * Looks up a given parameter in the fixture's argument list.
	 *
	 * If the value does not exist, the given default value is returned.
	 * @param paramName paramName the parameter name to look up
	 * @param defaultValue defaultValue the value to be returned if the parameter is missing
	 * @return the parameter value, if it could be found, {@code defaultValue} otherwise
	 */
	public final String getParam(final String paramName, final String defaultValue) {
		return FixtureTools.getArg(args, paramName, defaultValue,
				DependencyManager.getOrCreate(CrossReferenceHelper.class));
	}


	// Traversal //////////////////////////

	/**
	 * Initializes the fixture arguments, call {@code setUp},
	 * {@code fit.Fixture.doTable(Parse)} and {@code tearDown()}.
	 *
	 * @param table the table to be processed
	 */
	public void doTable(final Parse table) {
		FixtureTools.copyParamsToFixture(args, this,
				DependencyManager.getOrCreate(CrossReferenceHelper.class),
				DependencyManager.getOrCreate(TypeAdapterHelper.class));

		try {
			setUp();

			try {
				doRows(table.parts.more);
			} catch (final Exception e) {
				exception(table.parts.parts, e);
			}

			tearDown();
		} catch (final Exception e) {
			exception(table.parts.parts, e);
		}
	}

	protected void doRows(Parse rows) {
		while (rows != null) {
			Parse more = rows.more;
			doRow(rows);
			rows = more;
		}
	}

	protected void doRow(Parse row) {
		doCells(row.parts);
	}

	protected void doCells(Parse cells) {
		for (int i = 0; cells != null; i++) {
			try {
				doCell(cells, i);
			} catch (Exception e) {
				exception(cells, e);
			}
			cells = cells.more;
		}
	}

	protected void doCell(Parse cell, int columnNumber) {
		ignore(cell);
	}

	/**
	 * Does nothing. Override it to initialize the fixture.
	 * The method is called before doTables.
	 * @throws Exception any kind of exception aborts the execution of this fixture
	 */
	public void setUp() throws Exception {
	}

	/**
	 * Does nothing. Override it to tear down the fixture.
	 * The method is called after doTables.
	 *
	 * @throws Exception any kind of exception aborts the execution of this fixture
	 */
	public void tearDown() throws Exception {
	}

	// Annotation ///////////////////////////////

	public void right(Parse cell) {
		FitUtils.right(cell);
		counts.right++;
	}

	public void wrong(Parse cell) {
		FitUtils.wrong(cell);
		counts.wrong++;
	}

	protected void wrong(Parse cell, String actual) {
		wrong(cell);
		FitUtils.wrong(cell, actual);
	}

	public void info(Parse cell, String message) {
		FitUtils.info(cell, message);
	}

	protected void ignore(Parse cell) {
		FitUtils.ignore(cell);
		counts.ignores++;
	}

	protected void error(Parse cell, String message) {
		FitUtils.error(cell, message);
		counts.exceptions++;
	}

	protected void exception(Parse cell, Throwable exception) {
		FitUtils.exception(cell, exception);
		counts.exceptions++;
	}

	// Utility //////////////////////////////////

	public Object parse(final String text, final Class type) throws Exception {
		final ParserHelper helper = DependencyManager.getOrCreate(ParserHelper.class);
		final Object result = helper.parse(text, type, cellParameter);

		if (result != null) {
			return result;
		}
		throw new IllegalArgumentException("can't yet parse " + type);
	}

	/**
	 * Replacement of {@code check} which resolves cross-references
	 * before calling the original check method of fit.
	 *
	 *  @param cell the cell to check
	 *  @param a - TypeAdapter to use
	 */
	public void check(final Parse cell, final TypeAdapter a) {
		final TypeAdapterHelper taHelper = DependencyManager.getOrCreate(TypeAdapterHelper.class);
		TypeAdapter ta = FixtureTools.rebindTypeAdapter(a, cellParameter, taHelper);
		final CrossReferenceHelper helper = DependencyManager.getOrCreate(CrossReferenceHelper.class);
		ta = FixtureTools.processCell(cell, ta, this, helper);
		if (ta != null) {
			check2(cell, ta);
		}
	}

	public void check2(Parse cell, TypeAdapter a) {
		String text = cell.text();
		if (text.equals("")) {
			try {
				info(cell, a.toString(a.get()));
			} catch (Exception e) {
				info(cell, "error");
			}
		} else if (a == null) {
			ignore(cell);
		} else if (text.equals("error")) {
			try {
				Object result = a.invoke();
				wrong(cell, a.toString(result));
			} catch (IllegalAccessException e) {
				exception(cell, e);
			} catch (Exception e) {
				right(cell);
			}
		} else {
			try {
				Object result = a.get();
				if (a.equals(a.parse(text), result)) {
					right(cell);
				} else {
					wrong(cell, a.toString(result));
				}
			} catch (Exception e) {
				exception(cell, e);
			}
		}
	}

	/* Added by Rick, from FitNesse */
	protected String[] getArgs() {
		return args;
	}

	public Counts counts() {
		return counts;
	}

	/**
	 * Sets the parameter of the selected cell.
	 * @param parameter the cell parameter to set
	 * @see #getCellParameter() getCellParameter()
	 */
	protected void setCellParameter(final String parameter) {
		this.cellParameter = parameter;
	}

	/**
	 * Returns the parameter of the selected cell.
	 * @return the cell parameter
	 * @see #setCellParameter(String) setCellParameter(String)
	 */
	protected String getCellParameter() {
		return cellParameter;
	}

}
